diff --git a/src/main/java/org/spacious_team/table_wrapper/csv/CsvCellDataAccessObject.java b/src/main/java/org/spacious_team/table_wrapper/csv/CsvCellDataAccessObject.java
index 4f31ac8..16123f9 100644
--- a/src/main/java/org/spacious_team/table_wrapper/csv/CsvCellDataAccessObject.java
+++ b/src/main/java/org/spacious_team/table_wrapper/csv/CsvCellDataAccessObject.java
@@ -1,12 +1,20 @@
 package org.spacious_team.table_wrapper.csv;
 public class CsvCellDataAccessObject implements CellDataAccessObject<RowAndIndex, CsvTableRow> {
     public static final CsvCellDataAccessObject INSTANCE = new CsvCellDataAccessObject();
-    @Setter
-    @Getter
-    public static DateTimeFormatter dateTimeFormatter = null;
+    private final  DateTimeFormatter dateTimeFormatter;
+    private final  ZoneId defaultZone;
+    public CsvCellDataAccessObject() {
+        this(null, null);
+    }
+    public CsvCellDataAccessObject( DateTimeFormatter dateTimeFormatter,
+                                    ZoneId defaultZone) {
+        this.dateTimeFormatter = dateTimeFormatter;
+        this.defaultZone = defaultZone;
+    }
     @Override
     public  RowAndIndex getCell(CsvTableRow row, Integer cellIndex) {
-        return row.getCell(cellIndex).getRowAndIndex();
+         CsvTableCell cell = row.getCell(cellIndex);
+        return (cell == null) ? null : cell.getRowAndIndex();
     }
     @Override
     public  String getValue(RowAndIndex cell) {
@@ -15,6 +23,7 @@ public class CsvCellDataAccessObject implements CellDataAccessObject<RowAndIndex
     @Override
     public Instant getInstantValue(RowAndIndex cell) {
          String value = getValue(cell);
+        Objects.requireNonNull(value, "Not an instant");
         DateTimeFormatter formatter = (dateTimeFormatter != null) ?
                 dateTimeFormatter :
                 DateTimeFormatParser.getFor(value);
@@ -22,7 +31,7 @@ public class CsvCellDataAccessObject implements CellDataAccessObject<RowAndIndex
                 LocalDate.parse(value, formatter).atTime(12, 0) : 
                 LocalDateTime.parse(value, formatter);
         return dateTime
-                .atZone(ZoneOffset.systemDefault())
+                .atZone(defaultZone == null ? ZoneId.systemDefault() : defaultZone)
                 .toInstant();
     }
 }
diff --git a/src/main/java/org/spacious_team/table_wrapper/csv/CsvTable.java b/src/main/java/org/spacious_team/table_wrapper/csv/CsvTable.java
index 1af395f..b383f46 100644
--- a/src/main/java/org/spacious_team/table_wrapper/csv/CsvTable.java
+++ b/src/main/java/org/spacious_team/table_wrapper/csv/CsvTable.java
@@ -1,12 +1,14 @@
 package org.spacious_team.table_wrapper.csv;
 @ToString(callSuper = true)
 public class CsvTable extends AbstractTable<CsvTableRow> {
+    @Setter
     @Getter(AccessLevel.PROTECTED)
-    private final CellDataAccessObject<?, CsvTableRow> cellDataAccessObject = CsvCellDataAccessObject.INSTANCE;
-    protected CsvTable(AbstractReportPage<CsvTableRow> reportPage,
+    private CellDataAccessObject<?, CsvTableRow> cellDataAccessObject = CsvCellDataAccessObject.INSTANCE;
+    protected <T extends Enum<T> & TableHeaderColumn>
+    CsvTable(AbstractReportPage<CsvTableRow> reportPage,
              String tableName,
              TableCellRange tableRange,
-                       Class<? extends TableColumnDescription> headerDescription,
+             Class<T> headerDescription,
              int headersRowCount) {
         super(reportPage, tableName, tableRange, headerDescription, headersRowCount);
     }
diff --git a/src/main/java/org/spacious_team/table_wrapper/csv/CsvTableCell.java b/src/main/java/org/spacious_team/table_wrapper/csv/CsvTableCell.java
index 9b584f1..ea062e4 100644
--- a/src/main/java/org/spacious_team/table_wrapper/csv/CsvTableCell.java
+++ b/src/main/java/org/spacious_team/table_wrapper/csv/CsvTableCell.java
@@ -6,8 +6,14 @@ public class CsvTableCell extends AbstractTableCell<CsvTableCell.RowAndIndex> {
     public static CsvTableCell of(String[] row, int columnIndex) {
         return new CsvTableCell(new RowAndIndex(row, columnIndex));
     }
+    public static CsvTableCell of(String[] row, int columnIndex, CsvCellDataAccessObject dao) {
+        return new CsvTableCell(new RowAndIndex(row, columnIndex), dao);
+    }
     public CsvTableCell(RowAndIndex rowAndIndex) {
-        super(rowAndIndex, CsvCellDataAccessObject.INSTANCE);
+        this(rowAndIndex, CsvCellDataAccessObject.INSTANCE);
+    }
+    public CsvTableCell(RowAndIndex rowAndIndex, CsvCellDataAccessObject dao) {
+        super(rowAndIndex, dao);
         this.rowAndIndex = rowAndIndex;
     }
     @Override
diff --git a/src/main/java/org/spacious_team/table_wrapper/csv/CsvTableFactory.java b/src/main/java/org/spacious_team/table_wrapper/csv/CsvTableFactory.java
index 0fa24cf..bffa858 100644
--- a/src/main/java/org/spacious_team/table_wrapper/csv/CsvTableFactory.java
+++ b/src/main/java/org/spacious_team/table_wrapper/csv/CsvTableFactory.java
@@ -4,10 +4,11 @@ public class CsvTableFactory extends AbstractTableFactory<CsvReportPage> {
         super(CsvReportPage.class);
     }
     @Override
-    public Table create(ReportPage reportPage,
+    public <T extends Enum<T> & TableHeaderColumn>
+    Table create(ReportPage reportPage,
                  String tableName,
                  TableCellRange tableRange,
-                        Class<? extends TableColumnDescription> headerDescription,
+                 Class<T> headerDescription,
                  int headersRowCount) {
         return new CsvTable(
                 cast(reportPage),
diff --git a/src/main/java/org/spacious_team/table_wrapper/csv/CsvTableHelper.java b/src/main/java/org/spacious_team/table_wrapper/csv/CsvTableHelper.java
index 0798939..d80a576 100644
--- a/src/main/java/org/spacious_team/table_wrapper/csv/CsvTableHelper.java
+++ b/src/main/java/org/spacious_team/table_wrapper/csv/CsvTableHelper.java
@@ -1,5 +1,6 @@
 package org.spacious_team.table_wrapper.csv;
-class CsvTableHelper {
+@NoArgsConstructor(access = PRIVATE)
+final class CsvTableHelper {
     static TableCellAddress find(String[][] table, Object expected,
                                  int startRow, int endRow,
                                  int startColumn, int endColumn) {
@@ -24,7 +25,7 @@ class CsvTableHelper {
         for (int i = startColumn; i < endColumn; i++) {
             String cell = row[i];
             if (predicate.test(cell)) {
-                return new TableCellAddress(rowNum, i);
+                return TableCellAddress.of(rowNum, i);
             }
         }
         return NOT_FOUND;
diff --git a/src/main/java/org/spacious_team/table_wrapper/csv/CsvTableRow.java b/src/main/java/org/spacious_team/table_wrapper/csv/CsvTableRow.java
index 6e843d1..c9e8678 100644
--- a/src/main/java/org/spacious_team/table_wrapper/csv/CsvTableRow.java
+++ b/src/main/java/org/spacious_team/table_wrapper/csv/CsvTableRow.java
@@ -1,4 +1,5 @@
 package org.spacious_team.table_wrapper.csv;
+@EqualsAndHashCode(of ={"row", "rowNum"}, callSuper = false)
 public class CsvTableRow extends AbstractReportPageRow {
     private final String[] row;
     @Getter
@@ -35,7 +36,7 @@ public class CsvTableRow extends AbstractReportPageRow {
     }
     @Override
     public Iterator< TableCell> iterator() {
-        return new Iterator<>() {
+        return new Iterator< TableCell>() {
             private int cellIndex = 0;
             @Override
             public boolean hasNext() {
@@ -43,8 +44,11 @@ public class CsvTableRow extends AbstractReportPageRow {
             }
             @Override
             public  TableCell next() {
+                if (hasNext()) {
                     return getCell(cellIndex++);
                 }
+                throw new NoSuchElementException();
+            }
         };
     }
 }
diff --git a/src/main/java/org/spacious_team/table_wrapper/csv/DateTimeFormatParser.java b/src/main/java/org/spacious_team/table_wrapper/csv/DateTimeFormatParser.java
index cd5378a..573ca9a 100644
--- a/src/main/java/org/spacious_team/table_wrapper/csv/DateTimeFormatParser.java
+++ b/src/main/java/org/spacious_team/table_wrapper/csv/DateTimeFormatParser.java
@@ -1,5 +1,6 @@
 package org.spacious_team.table_wrapper.csv;
-class DateTimeFormatParser {
+@NoArgsConstructor(access = PRIVATE)
+final class DateTimeFormatParser {
     private static final Map<Integer, DateTimeFormatter> dateTimeFormatters = new ConcurrentHashMap<>();
     static DateTimeFormatter getFor(String dateTime) {
         return (dateTime.length() == 10) ?
@@ -20,7 +21,8 @@ class DateTimeFormatParser {
         return getDateFormatter(isYearAtFirst, dateSplitter);
     }
     static DateTimeFormatter getForDateTime(String dateTime) {
-        boolean isDateAtFirst, isYearAtFirst;
+        boolean isDateAtFirst;
+        boolean isYearAtFirst;
         char dateSplitter;
         if (dateTime.charAt(2) == ':') {
             isDateAtFirst = false;
diff --git a/src/main/java/org/spacious_team/table_wrapper/csv/package-info.java b/src/main/java/org/spacious_team/table_wrapper/csv/package-info.java
new file mode 100644
index 0000000..5c3f752
--- /dev/null
+++ b/src/main/java/org/spacious_team/table_wrapper/csv/package-info.java
@@ -0,0 +1,2 @@
+@DefaultQualifier(NonNull.class)
+package org.spacious_team.table_wrapper.csv;
diff --git a/src/test/java/org/spacious_team/table_wrapper/csv/CsvTableCellTest.java b/src/test/java/org/spacious_team/table_wrapper/csv/CsvTableCellTest.java
index 2bb3547..142724d 100644
--- a/src/test/java/org/spacious_team/table_wrapper/csv/CsvTableCellTest.java
+++ b/src/test/java/org/spacious_team/table_wrapper/csv/CsvTableCellTest.java
@@ -1,11 +1,128 @@
 package org.spacious_team.table_wrapper.csv;
 class CsvTableCellTest {
     @ParameterizedTest
-    @ValueSource(ints = {1, 2, 3, 4, 5})
+    @ValueSource(ints = {0, 1, 2, 3})
     void getColumnIndex(int colNum) {
-        String[] row = new String[5];
-        CsvTableCell.RowAndIndex rowAndIndex = new CsvTableCell.RowAndIndex(row, colNum);
-        CsvTableCell csv = new CsvTableCell(rowAndIndex);
-        assertEquals(colNum, csv.getColumnIndex());
+        String[] row = new String[2];
+        CsvTableCell cell = CsvTableCell.of(row, colNum);
+        assertEquals(colNum, cell.getColumnIndex());
+    }
+    @Test
+    void getValue() {
+        String[] row = new String[]{"object1", "object2"};
+        CsvTableCell cell = CsvTableCell.of(row, 0);
+        assertEquals("object1", cell.getValue());
+        CsvTableCell notEqualsCell = CsvTableCell.of(row, 1);
+        assertNotEquals(notEqualsCell.getValue(), cell.getValue());
+    }
+    @Test
+    void getIntValue() {
+        String[] row = new String[]{"1024", "1025"};
+        CsvTableCell cell = CsvTableCell.of(row, 0);
+        assertEquals(1024, cell.getIntValue());
+        CsvTableCell notEqualsCell = CsvTableCell.of(row, 1);
+        assertNotEquals(notEqualsCell.getIntValue(), cell.getIntValue());
+    }
+    @Test
+    void getLongValue() {
+        String[] row = new String[]{"1024", "1025"};
+        CsvTableCell cell = CsvTableCell.of(row, 0);
+        assertEquals(1024L, cell.getLongValue());
+        CsvTableCell notEqualsCell = CsvTableCell.of(row, 1);
+        assertNotEquals(notEqualsCell.getLongValue(), cell.getLongValue());
+    }
+    @Test
+    void getDoubleValue() {
+        String[] row = new String[]{"10.24", "10.24000", "10.2400000000000000000000000000000000001", "10.24001"};
+        CsvTableCell cell0 = CsvTableCell.of(row, 0);
+        assertEquals(10.24D, cell0.getDoubleValue());
+        CsvTableCell cell1 = CsvTableCell.of(row, 1);
+        assertEquals(10.24D, cell1.getDoubleValue());
+        CsvTableCell cell2 = CsvTableCell.of(row, 2);
+        assertEquals(10.24D, cell2.getDoubleValue());
+        CsvTableCell cell3 = CsvTableCell.of(row, 3);
+        assertNotEquals(cell2.getDoubleValue(), cell3.getDoubleValue());
+    }
+    @Test
+    void getBigDecimalValue() {
+        BigDecimal expected = new BigDecimal("10.24");
+        String[] row = new String[]{"10.24", "10.24000", "10.2400000000000000000000000000000000001"};
+        CsvTableCell cell0 = CsvTableCell.of(row, 0);
+        CsvTableCell cell1 = CsvTableCell.of(row, 1);
+        CsvTableCell cell2 = CsvTableCell.of(row, 2);
+        assertEquals(expected, cell0.getBigDecimalValue());
+        assertNotEquals(expected, cell1.getBigDecimalValue());
+        assertNotEquals(expected, cell2.getBigDecimalValue());
+        assertEquals(0, cell0.getBigDecimalValue().compareTo(cell1.getBigDecimalValue()));
+        assertEquals(-1, cell0.getBigDecimalValue().compareTo(cell2.getBigDecimalValue()));
+        assertEquals(-1, cell1.getBigDecimalValue().compareTo(cell2.getBigDecimalValue()));
+    }
+    @Test
+    void getStringValue() {
+        String[] row = new String[]{"object1", "object2"};
+        CsvTableCell cell = CsvTableCell.of(row, 0);
+        assertEquals("object1", cell.getStringValue());
+        CsvTableCell notEqualsCell = CsvTableCell.of(row, 1);
+        assertNotEquals(notEqualsCell.getStringValue(), cell.getStringValue());
+    }
+    @ParameterizedTest
+    @ValueSource(strings = {"2022-10-11", "11-10-2022", "11 10 2022", "2022/10/11", "11.10.2022"})
+    void getInstantValueWithDate(String date) {
+        Instant expected = LocalDate.of(2022, 10, 11)
+                .atTime(12, 0)
+                .atZone(ZoneOffset.systemDefault())
+                .toInstant();
+        String[] row = new String[]{date};
+        CsvTableCell cell = CsvTableCell.of(row, 0);
+        assertEquals(expected, cell.getInstantValue());
+    }
+    @ParameterizedTest
+    @ValueSource(strings = {"2022-10-11 03:01:00", "03:01:00 11-10-2022", "11 10 2022 03:01:00",
+            "03:01:00 2022/10/11", "11.10.2022 03:01:00"})
+    void getInstantValueWithDateTime(String dateTime) {
+        Instant expected = LocalDate.of(2022, 10, 11)
+                .atTime(3, 1)
+                .atZone(ZoneOffset.systemDefault())
+                .toInstant();
+        String[] row = new String[]{dateTime};
+        CsvTableCell cell = CsvTableCell.of(row, 0);
+        assertEquals(expected, cell.getInstantValue());
+    }
+    @ParameterizedTest
+    @ValueSource(strings = "2022-10-11T03:01:00+03:00")
+    void getInstantValueWithFormat(String dateTime) {
+        ZoneId zoneId = ZoneOffset.systemDefault();
+        CsvCellDataAccessObject dao = new CsvCellDataAccessObject(DateTimeFormatter.ISO_DATE_TIME, zoneId);
+        Instant expected = LocalDate.of(2022, 10, 11)
+                .atTime(3, 1)
+                .atZone(zoneId)
+                .toInstant();
+        String[] row = new String[]{dateTime};
+        CsvTableCell cell = CsvTableCell.of(row, 0, dao);
+        assertEquals(expected, cell.getInstantValue());
+    }
+    @ParameterizedTest
+    @ValueSource(strings = {"2022-10-11 03:01:00", "03:01:00 11-10-2022", "11 10 2022 03:01:00",
+            "03:01:00 2022/10/11", "11.10.2022 03:01:00"})
+    void getLocalDateTimeValue(String dateTime) {
+        LocalDateTime expected = LocalDate.of(2022, 10, 11)
+                .atTime(3, 1);
+        String[] row = new String[]{dateTime};
+        CsvTableCell cell = CsvTableCell.of(row, 0);
+        assertEquals(expected, cell.getLocalDateTimeValue());
+    }
+    @Test
+    void equals() {
+        String[] row = new String[]{"abc", "abc"};
+        assertEquals(
+                CsvTableCell.of(row, 0),
+                CsvTableCell.of(row, 1));
+    }
+    @Test
+    void testHashCode() {
+        String[] row = new String[]{"abc", "abc"};
+        assertEquals(
+                CsvTableCell.of(row, 0).hashCode(),
+                CsvTableCell.of(row, 1).hashCode());
     }
 }
diff --git a/src/test/java/org/spacious_team/table_wrapper/csv/CsvTableRowTest.java b/src/test/java/org/spacious_team/table_wrapper/csv/CsvTableRowTest.java
index a5d5a01..0346a01 100644
--- a/src/test/java/org/spacious_team/table_wrapper/csv/CsvTableRowTest.java
+++ b/src/test/java/org/spacious_team/table_wrapper/csv/CsvTableRowTest.java
@@ -1,19 +1,32 @@
 package org.spacious_team.table_wrapper.csv;
 class CsvTableRowTest {
+    static Stream<Arguments> getRowNumRowColNum() {
+        String[] row = new String[]{"1", "2.1", "abc", "2020-01-01 01:02:03"};
+        return Stream.of(
+                Arguments.of(1, row, 10),
+                Arguments.of(5, row, 2),
+                Arguments.of(8, new String[]{}, 11)
+        );
+    }
     @ParameterizedTest
-    @MethodSource("indexAndRow")
+    @MethodSource("getRowNumRowColNum")
     void getCell(int rowNum, String[] row, int colNum) {
-        CsvTableCell cell;
-        CsvTableRow csvRow = new CsvTableRow(row, rowNum);
+        CsvTableRow csvTableRow = new CsvTableRow(row, rowNum);
         if (colNum >= row.length) {
-            assertNull(csvRow.getCell(colNum));
+            assertNull(csvTableRow.getCell(colNum));
         } else {
-            cell = CsvTableCell.of(row, colNum);
-            assertEquals(cell, csvRow.getCell(colNum));
+            CsvTableCell cell = CsvTableCell.of(row, colNum);
+            assertEquals(cell, csvTableRow.getCell(colNum));
         }
     }
     @ParameterizedTest
-    @MethodSource("indexAndRow")
+    @MethodSource("getRowNumRowColNum")
+    void getRowNum(int rowNum, String[] row) {
+        CsvTableRow csvTableRow = new CsvTableRow(row, rowNum);
+        assertEquals(rowNum, csvTableRow.getRowNum());
+    }
+    @ParameterizedTest
+    @MethodSource("getRowNumRowColNum")
     void getFirstCellNum(int rowNum, String[] row) {
         CsvTableRow csv = new CsvTableRow(row, rowNum);
         if (row.length == 0) {
@@ -23,17 +36,47 @@ class CsvTableRowTest {
         }
     }
     @ParameterizedTest
-    @MethodSource("indexAndRow")
+    @MethodSource("getRowNumRowColNum")
     void getLastCellNum(int rowNum, String[] row) {
         CsvTableRow csv = new CsvTableRow(row, rowNum);
         assertEquals(row.length - 1, csv.getLastCellNum());
     }
-    private static Stream<Arguments> indexAndRow() {
-        String[] row = new String[]{"1", "2.1", "abc", "2020-01-01 01:02:03"};
-        return Stream.of(
-                Arguments.of(1, row, 10),
-                Arguments.of(5, row, 2),
-                Arguments.of(8, new String[]{}, 11)
-        );
+    @Test
+    void rowContains() {
+        String[] row = new String[]{null, "1", "2.1", "2.20", "abc", "2020-01-01T01:02:03"};
+        CsvTableRow csvTableRow = new CsvTableRow(row, 0);
+        assertTrue(csvTableRow.rowContains(null));
+        assertTrue(csvTableRow.rowContains(1));
+        assertTrue(csvTableRow.rowContains(2.1D));
+        assertFalse(csvTableRow.rowContains(2.2D)); 
+        assertTrue(csvTableRow.rowContains("abc"));
+        LocalDateTime localDateTime = LocalDateTime.of(2020, 1, 1, 1, 2, 3);
+        assertTrue(csvTableRow.rowContains(localDateTime));
+    }
+    @Test
+    void iterator() {
+        String[] row = new String[]{null, "1", "2.1", "2.20", "abc", "2020-01-01T01:02:03"};
+        CsvTableRow csvTableRow = new CsvTableRow(row, 0);
+        List<CsvTableCell> expected = IntStream.range(0, row.length)
+                .mapToObj(colNum -> CsvTableCell.of(row, colNum))
+                .collect(Collectors.toList());
+        List<TableCell> actual = StreamSupport.stream(
+                        Spliterators.spliteratorUnknownSize(csvTableRow.iterator(), 0),
+                        false)
+                .collect(Collectors.toList());
+        assertEquals(expected, actual);
+    }
+    @Test
+    void equals() {
+        String[] row1 = new String[]{"1", "2"};
+        String[] row2 = new String[]{"1", "2"};
+        assertEquals(new CsvTableRow(row1, 0), new CsvTableRow(row2, 0));
+        assertNotEquals(new CsvTableRow(row1, 0), new CsvTableRow(row1, 1));
+    }
+    @Test
+    void testHashCode() {
+        String[] row1 = new String[]{"1", "2"};
+        String[] row2 = new String[]{"1", "2"};
+        assertEquals(new CsvTableRow(row1, 0).hashCode(), new CsvTableRow(row2, 0).hashCode());
     }
 }
